//
//  ProjectManager.swift
//  DesaiVideo
//
//  Created by Abylaikhan Abilkayr on 23.10.2025.
//

import SwiftData
import Foundation

// MARK: - ProjectManager

@MainActor
final class ProjectManager {
    static let shared = ProjectManager()
    
    private let context: ModelContext
    
    private init() {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SwiftData –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        context = try! ModelContext(
            ModelContainer(for: Project.self, Transcription.self, SummaryChapter.self)
        )
    }
    
    // MARK: - Project Creation
    
    /// –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ `queued` –æ—Ç –±—ç–∫–∞
    func createQueuedProject(
        response: BackendResponse,
        fileType: Project.FileType,
        taskType: Project.TaskType,
        localFilePath: String?,
        duration: Double?
    ) {
        guard let id = UUID(uuidString: response.id) else { return }
        
        if let existing = try? fetchById(id), existing != nil {
            print("‚ö†Ô∏è Project already exists with id: \(id)")
            return
        }
        
        let project = Project(
            id: id,
            fileType: fileType,
            taskType: taskType,
            status: .queued,
            duration: duration,
            localFilePath: localFilePath
        )
        
        context.insert(project)
        save()
        print("üì¶ Created project (queued) id: \(id)")
    }
    
    // MARK: - Status Handling
    
    /// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç –±—ç–∫–∞ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç Project –≤ SwiftData
    
    func handleBackendResponse(
        _ response: BackendResponse,
        fileType: Project.FileType,
        taskType: Project.TaskType,
        localFilePath: String?,
        duration: Double?
    ) {        
        guard let id = UUID(uuidString: response.id) else {
            print("‚ùå Invalid UUID in response")
            return
        }

        // –ï—Å–ª–∏ –ø—Ä–æ–µ–∫—Ç–∞ –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –ø—Ä–∏ queued
        if (try? fetchById(id)) == nil, response.status == "queued" {
            createQueuedProject(
                response: response,
                fileType: fileType,
                taskType: taskType,
                localFilePath: localFilePath,
                duration: duration
            )
            return
        }
        
        switch response.status {
        case "started":
            updateStatus(for: id, to: .started)
            
        case "failed":
            updateStatus(for: id, to: .failed)
            
        case "finished":
            updateStatus(for: id, to: .finished)
            updateResult(for: id, result: response.result)

            Task {
                do {
                    // 0) –°–Ω–∏–º–æ–∫ –ø–æ–ª–µ–π –î–û –ª—é–±–æ–≥–æ await
                    guard let snap = await MainActor.run(body: { self.snapshot(for: id) }) else { return }
                    let fileType = snap.fileType
                    var localPath = snap.localFilePath // –º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
                    // let taskType = snap.taskType // –µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è
                    // let duration = snap.duration  // –µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è

                    // 1) –ü—Ä–æ–≤–µ—Ä—è–µ–º result
                    guard let urlStr = response.result,
                          let remoteURL = URL(string: urlStr) else {
                        // –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ‚Üí —É–≤–µ–¥–æ–º–∏–º –∏ —É–¥–∞–ª–∏–º –ø–æ id
                        NotificationCenter.default.post(name: .cancelTask, object: nil, userInfo: ["id": id])
                        await MainActor.run { self.deleteById(id) }
                        return
                    }

                    // 2) –ö–∞—á–∞–µ–º —Ñ–∞–π–ª (await ‚Äî —É–∂–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ, –º–æ–¥–µ–ª—å –º—ã –Ω–µ —Ç—Ä–æ–≥–∞–µ–º)
                    let downloadedFile = try await NetworkManager.shared.downloadFile(from: remoteURL.absoluteString)

                    switch fileType {
                    case .video:
                        // 3) –†–∞–±–æ—Ç–∞–µ–º —Å –ª–æ–∫–∞–ª—å–Ω–æ–π –∫–æ–ø–∏–µ–π –ø—É—Ç–∏, –∞ –Ω–µ —Å project
                        if let path = localPath, !FileManager.default.fileExists(atPath: path) {
                            // –ø—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ id
                            let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                            let restored = docs.appendingPathComponent("Projects/\(id.uuidString).mp4")
                            if FileManager.default.fileExists(atPath: restored.path) {
                                print("‚ôªÔ∏è Restored missing video file for \(id)")
                                localPath = restored.path
                                await MainActor.run {
                                    self.updateLocalPath(for: id, path: restored.path)
                                }
                            } else {
                                print("‚ö†Ô∏è Video file not found anywhere for \(id)")
                                // –º–æ–∂–Ω–æ –ø–æ—Å–ª–∞—Ç—å cancel / —É–¥–∞–ª–∏—Ç—å –ø—Ä–æ–µ–∫—Ç
                                NotificationCenter.default.post(name: .cancelTask, object: nil, userInfo: ["id": id])
                                await MainActor.run { self.deleteById(id) }
                                return
                            }
                        }

                        guard let path = localPath else {
                            print("‚ùå No local video path for project \(id)")
                            return
                        }

                        // 4) –ú–µ—Ä–¥–∂ (—Ç—è–∂—ë–ª—ã–π await ‚Äî –≤—Å—ë –µ—â—ë –±–µ–∑–æ–ø–∞—Å–Ω–æ)
                        let videoURL = URL(fileURLWithPath: path)
                        let mergedURL = try await VideoAudioMerger.merge(videoURL: videoURL, with: downloadedFile)
                        let permanentURL = try moveToPersistentStorage(fileURL: mergedURL, id: id)

                        // 5) –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–¥–µ–ª—å –¢–û–õ–¨–ö–û —á–µ—Ä–µ–∑ –º–µ—Ç–æ–¥—ã –ø–æ id
                        await MainActor.run {
                            self.updateLocalPath(for: id, path: permanentURL.path)
                            self.updateName(for: id, name: permanentURL.lastPathComponent)
                            self.save()
                            print("‚úÖ Video merged and saved at: \(permanentURL.lastPathComponent)")
                        }

                    case .audio:
                        let permanentURL = try self.moveAudioToPersistentStorage(fileURL: downloadedFile, id: id)
                        await MainActor.run {
                            self.updateLocalPath(for: id, path: permanentURL.path)
                            self.updateName(for: id, name: permanentURL.lastPathComponent)
                            self.save()
                            print("‚úÖ Audio saved at: \(permanentURL.lastPathComponent)")
                        }
                    }

                    // 6) UI —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                    NotificationCenter.default.post(name: .taskDidFinish, object: nil, userInfo: ["id": id])

                    // 7) –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏/–≥–ª–∞–≤—ã ‚Äî —Ç–æ–ª—å–∫–æ –º–µ—Ç–æ–¥–∞–º–∏ –ø–æ id (–æ–Ω–∏ @MainActor)
                    if let trans = response.transcriptions {
                        await MainActor.run {
                            self.updateTranscriptions(for: id, transcriptions: trans.map {
                                Transcription(speaker: $0.speaker, text: $0.text, start: $0.start, end: $0.end)
                            })
                        }
                    }
                    if let chapters = response.summaryChapters {
                        await MainActor.run {
                            self.updateChapters(for: id, chapters: chapters.map {
                                SummaryChapter(start: $0.start, title: $0.title)
                            })
                        }
                    }

                } catch {
                    print("‚ùå Failed to process response for \(id):", error)
                    await MainActor.run { self.updateStatus(for: id, to: .failed) }
                }
            }

        default:
            print("‚ö†Ô∏è Unknown status: \(response.status)")
        }
    }
    
    
    
    private func moveToPersistentStorage(fileURL: URL, id: UUID) throws -> URL {
        let fileManager = FileManager.default
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º .documentDirectory ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ, –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è —Å–∏—Å—Ç–µ–º–æ–π
        let documentsDir = try fileManager.url(
            for: .documentDirectory,
            in: .userDomainMask,
            appropriateFor: nil,
            create: true
        )
        
        let projectsDir = documentsDir.appendingPathComponent("Projects", isDirectory: true)
        if !fileManager.fileExists(atPath: projectsDir.path) {
            try fileManager.createDirectory(at: projectsDir, withIntermediateDirectories: true)
        }
        
        var destinationURL = projectsDir.appendingPathComponent("\(id.uuidString).mp4")
        
        // –ï—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å ‚Äî —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π
        if fileManager.fileExists(atPath: destinationURL.path) {
            try fileManager.removeItem(at: destinationURL)
        }
        
        // ‚úÖ 1. –°–Ω–∞—á–∞–ª–∞ –∫–æ–ø–∏—Ä—É–µ–º –≤–æ "–≤–µ—á–Ω–æ –∂–∏–≤–æ–π" Documents
        try fileManager.copyItem(at: fileURL, to: destinationURL)
        
        // ‚úÖ 2. –¢–µ–ø–µ—Ä—å –±–µ–∑–æ–ø–∞—Å–Ω–æ —É–¥–∞–ª—è–µ–º tmp-–æ—Ä–∏–≥–∏–Ω–∞–ª
        if fileManager.fileExists(atPath: fileURL.path) {
            try? fileManager.removeItem(at: fileURL)
            print("üßπ Removed temporary merged file at \(fileURL.lastPathComponent)")
        }
        
        // ‚úÖ 3. –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ–±—ã —Ñ–∞–π–ª –Ω–µ —É–¥–∞–ª—è–ª—Å—è —Å–∏—Å—Ç–µ–º–æ–π
        var resourceValues = URLResourceValues()
        resourceValues.isExcludedFromBackup = false // true = –Ω–µ –≤–∫–ª—é—á–∞—Ç—å –≤ iCloud backup
        try destinationURL.setResourceValues(resourceValues)
        
        print("üìÅ Video saved permanently at: \(destinationURL.path)")
        return destinationURL
    }
    
    
    private func moveAudioToPersistentStorage(fileURL: URL, id: UUID) throws -> URL {
        let fileManager = FileManager.default
        
        let documentsDir = try fileManager.url(
            for: .documentDirectory,
            in: .userDomainMask,
            appropriateFor: nil,
            create: true
        )
        
        let projectsDir = documentsDir.appendingPathComponent("Projects", isDirectory: true)
        if !fileManager.fileExists(atPath: projectsDir.path) {
            try fileManager.createDirectory(at: projectsDir, withIntermediateDirectories: true)
        }
        
        var destinationURL = projectsDir.appendingPathComponent("\(id.uuidString).mp3")
        
        if fileManager.fileExists(atPath: destinationURL.path) {
            try fileManager.removeItem(at: destinationURL)
        }
        
        try fileManager.copyItem(at: fileURL, to: destinationURL)
        
        var resourceValues = URLResourceValues()
        resourceValues.isExcludedFromBackup = false
        try destinationURL.setResourceValues(resourceValues)
        
        print("üìÅ Audio saved permanently at: \(destinationURL.path)")
        return destinationURL
    }
    
    
    // MARK: - CRUD Operations
    
    func fetchAll() -> [Project] {
        let descriptor = FetchDescriptor<Project>(
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        var projects = (try? context.fetch(descriptor)) ?? []
        
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        
        for project in projects {
            guard let path = project.localFilePath else { continue }
            
            if !FileManager.default.fileExists(atPath: path) {
                var recovered: URL?
                
                switch project.fileType {
                case .video:
                    let videoPath = docs.appendingPathComponent("Projects/\(project.id.uuidString).mp4")
                    if FileManager.default.fileExists(atPath: videoPath.path) {
                        recovered = videoPath
                        print("‚ôªÔ∏è Restored video file for \(project.id)")
                    }
                    
                case .audio:
                    let audioPath = docs.appendingPathComponent("Projects/\(project.id.uuidString).mp3")
                    if FileManager.default.fileExists(atPath: audioPath.path) {
                        recovered = audioPath
                        print("‚ôªÔ∏è Restored audio file for \(project.id)")
                    }
                }
                
                if let recovered {
                    project.localFilePath = recovered.path
                    save()
                } else {
                    print("‚ö†Ô∏è Missing file for project \(project.id)")
                }
            }
        }
        
        return projects
    }
        
    func updateStatus(for id: UUID, to status: Project.Status) {
        guard let project = try? fetchById(id) else { return }
        project.status = status
        if status == .failed {
            delete(project)
        } else {
            save()
        }
    }
    
    func updateResult(for id: UUID, result: String?) {
        guard let project = try? fetchById(id) else { return }
        project.result = result
        save()
    }
    
    func updateName(for id: UUID, name: String?) {
        guard let project = try? fetchById(id) else { return }
        project.name = name
        save()
    }
    
    func updateTranscriptions(for id: UUID, transcriptions: [Transcription]) {
        guard let project = try? fetchById(id) else { return }
        project.transcriptions = transcriptions
        save()
    }
    
    func updateChapters(for id: UUID, chapters: [SummaryChapter]) {
        guard let project = try? fetchById(id) else { return }
        project.summaryChapters = chapters
        save()
    }
    
    func delete(_ project: Project) {
        context.delete(project)
        save()
    }
    
    func deleteOldProject(for id: UUID) {
        guard let project = try? fetchById(id) else { return }
        delete(project)
    }
    
    // MARK: - Private Helpers
    
    private func fetchById(_ id: UUID) throws -> Project? {
        let descriptor = FetchDescriptor<Project>(
            predicate: #Predicate { $0.id == id }
        )
        return try context.fetch(descriptor).first
    }
    
    private func save() {
        do {
            try context.save()
            NotificationCenter.default.post(name: .projectsDidUpdate, object: nil)
        } catch {
            print("‚ùå Failed to save context: \(error)")
        }
    }
    
    // –õ–æ–∫–∞–ª—å–Ω—ã–π value-—Ç–∏–ø, —á—Ç–æ–±—ã –Ω–µ —Ç–∞—Å–∫–∞—Ç—å –∑–∞ —Å–æ–±–æ–π –∂–∏–≤—É—é –º–æ–¥–µ–ª—å
    private struct ProjectSnapshot {
        let fileType: Project.FileType
        let taskType: Project.TaskType
        let localFilePath: String?
        let duration: Double?
    }

    @MainActor
    private func snapshot(for id: UUID) -> ProjectSnapshot? {
        guard let p = try? fetchById(id) else { return nil }
        return ProjectSnapshot(
            fileType: p.fileType,
            taskType: p.taskType,
            localFilePath: p.localFilePath,
            duration: p.duration
        )
    }

    func updateLocalPath(for id: UUID, path: String) {
        guard let project = try? fetchById(id) else { return }
        project.localFilePath = path
        save()
    }

    func deleteById(_ id: UUID) {
        guard let project = try? fetchById(id) else { return }
        delete(project)
    }
}

extension ProjectManager {
    /// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ (queued / started)
    /// –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç –∏—Ö –ø–æ–ª–ª–∏–Ω–≥.
    func checkUnfinishedTasks() {
        Task { [weak self] in
            guard let self else { return }

            let unfinished = fetchAll().filter {
                $0.status == .queued || $0.status == .started
            }

            guard !unfinished.isEmpty else {
                print("‚úÖ –ù–µ—Ç –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö –∑–∞–¥–∞—á")
                return
            }

            print("‚ö†Ô∏è –ù–∞–π–¥–µ–Ω—ã –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏: \(unfinished.count)")

            for project in unfinished {
                guard let id = project.id as UUID?,
                      let path = project.localFilePath else { continue }

                let url = URL(fileURLWithPath: path)
                let duration = project.duration ?? 0

                // –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–Ω–æ–≤–æ TaskPoller –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
                await TaskPoller.shared.startPolling(
                    id: id,
                    interval: 5,
                    timeout: 600,
                    fileType: project.fileType,
                    taskType: project.taskType,
                    localFilePath: path,
                    duration: duration
                ) { taskId in
                    try await NetworkManager.shared.fetchTaskStatus(taskId: taskId)
                }

                print("üîÅ –í–æ–∑–æ–±–Ω–æ–≤–ª—ë–Ω –ø–æ–ª–ª–∏–Ω–≥ –¥–ª—è –∑–∞–¥–∞—á–∏ \(id)")
            }
        }
    }
}


extension ProjectManager {
    func fetchByIdSync(_ id: UUID) -> Project? {
        let descriptor = FetchDescriptor<Project>(
            predicate: #Predicate { $0.id == id }
        )
        return try? context.fetch(descriptor).first
    }
}

// MARK: - Ensure Permanent Copy of Input File
extension ProjectManager {
    /// –ü–µ—Ä–µ–º–µ—â–∞–µ—Ç –∏–ª–∏ –∫–æ–ø–∏—Ä—É–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª (–∞—É–¥–∏–æ/–≤–∏–¥–µ–æ) –≤ Documents/Projects.
    /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π URL, –ø—Ä–∏–≥–æ–¥–Ω—ã–π –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ `localFilePath`.
    func moveSourceToPersistentStorage(sourceURL: URL, id: UUID, fileType: Project.FileType) throws -> URL {
        let fileManager = FileManager.default
        let documentsDir = try fileManager.url(
            for: .documentDirectory,
            in: .userDomainMask,
            appropriateFor: nil,
            create: true
        )
        
        let projectsDir = documentsDir.appendingPathComponent("Projects", isDirectory: true)
        if !fileManager.fileExists(atPath: projectsDir.path) {
            try fileManager.createDirectory(at: projectsDir, withIntermediateDirectories: true)
        }
        
        let ext = (fileType == .video) ? "mp4" : "m4a"
        let destination = projectsDir.appendingPathComponent("\(id.uuidString).\(ext)")
        
        // –ï—Å–ª–∏ —Ñ–∞–π–ª –≤—Ä–µ–º–µ–Ω–Ω—ã–π (tmp), –∫–æ–ø–∏—Ä—É–µ–º
        if sourceURL.path.contains("/tmp/") {
            if fileManager.fileExists(atPath: destination.path) {
                try fileManager.removeItem(at: destination)
            }
            try fileManager.copyItem(at: sourceURL, to: destination)
            print("üì¶ Copied temp file to permanent: \(destination.lastPathComponent)")
        } else {
            // –ï—Å–ª–∏ —É–∂–µ –≤ Documents ‚Äî –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
            if !fileManager.fileExists(atPath: destination.path) {
                try fileManager.copyItem(at: sourceURL, to: destination)
            }
        }
        
        return destination
    }
}

extension ProjectManager {
    func fetchSafeCopyById(_ id: UUID) -> (fileType: Project.FileType, taskType: Project.TaskType, localFilePath: String?)? {
        guard let project = fetchByIdSync(id) else { return nil }
        return (project.fileType, project.taskType, project.localFilePath)
    }
}

